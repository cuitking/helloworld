typedef struct lua_State lua_State;
typedef int (*lua_CFunction)(lua_State* L);
typedef const char* (*GetStrByIntF)(int value);

lua_State*  m_pMainThread;
struct StringHash{};
typedef boost::unordered_map<std::string, scgl::CLuaFunctor*, StringHash>	LuaFunctorMap;
struct CLuaHelper::Impl
	{
		LuaFunctorMap		luaFunctors;
		scgl::CLuaFunctor*	Process;
		bool				mainLoaded;
		bool				countProcess;
		CallCountInfoMap	processCountInfoList;		// process调用函数性能统计
		GetStrByIntF		GetProcessIDName;
		'''
	};
CLuaHelper::CLuaHelper()
		: m_impl(new Impl)
		, m_pMainThread(NULL)
		, m_bChunkLoaded(false)
		, m_pExternalLuaLoader(NULL)
	{
		CreateMainState();
	}
void CLuaHelper::CreateMainState()
	{
		m_pMainThread = luaL_newstate();//创建一个lua状态机.
		//Lua脚本的编译执行是相互独立的，在不同的线程上执行。通过luaL_newstate()函数可以申请一个虚拟机，返回指针类型
		//lua_State。今后其他所有Lua Api函数的调用都需要此指针作为第一参数，用来指定某个虚拟机
		luaL_openlibs(m_pMainThread); //Opens all standard Lua libraries into the given state.
		lua_pushthread(m_pMainThread); //把 L 中提供的线程压栈。 如果这个线程是当前状态机的主线程的话，返回1.
		lua_setglobal(m_pMainThread, "g_mainState"); // lua_setglobal的作用是把栈顶的数据传到Lua环境中作为全局变量
#ifdef _DEBUG
		PushBoolean("DEBUG", true);
#endif
	}
bool CLuaHelper::PushBoolean(const char* globalName, bool boolean)
{
	if (IsStackFull()) //判断lua堆栈是否满了 
	{
		return false;
	}
	/*
	bool CLuaHelper::IsStackFull()
	{
		return !HaveFreeStackSlot(1);
	}
	bool CLuaHelper::HaveFreeStackSlot(int nFreeSlot)
	{
		if (lua_checkstack(m_pMainThread, nFreeSlot)) return true;
		//扩大栈的可用尺寸，栈的默认尺寸是20，此函数会确保堆栈上至少有 sz 个空位。如果不能把堆栈扩展到相应的尺寸，
		函数返回 false 。这个函数永远不会缩小堆栈；如果堆栈已经比需要的大了，那么就放在那里不会产生变化。
		return false;
	}
	*/

	int n = lua_gettop(m_pMainThread);//返回栈顶索引（即栈长度）  
	//lua_settop将栈顶设置为一个指定的位置，即修改栈中元素的数量。如果值比原栈顶高，则高的部分nil补足，如果值比原栈低，
	//则原栈高出的部分舍弃。所以可以用lua_settop(0)来清空栈。
	lua_pushboolean(m_pMainThread, boolean);//向lua堆栈中压入一个bool值
	lua_setglobal(m_pMainThread, globalName);//把压入栈顶的值作为lua中的全局变量
	ClearStackTempData(n);
	/*
	void CLuaHelper::ClearStackTempData(int nTempDataAmount)
	{
		lua_pop(m_pMainThread, lua_gettop(m_pMainThread) - nTempDataAmount);
		//弹出向lua中压栈的元素
	}
	*/
	return true;
}




scgl::SingletonHolder< CLuaHelper > SLuaHelper; luahelper作为一个单例存在于服务器中
GetLuaHelper()--- SLuaHelper::Instance();


1..启动服务器首先创建一个:luaProcessor
scgl::CLuaProcessor luaProcessor;

CLuaProcessor构成:
class CLuaProcessor{
	
	private:
		struct Impl;
		Impl* m_impl;
};
struct CLuaProcessor::Impl
	{
		INet*							net;
		CLuaBinder<CLuaProcessor>		luaBinder;
		int processRef;
		Impl()
			:luaBinder("scglNet")
			, processRef(0)
			, net(NULL)
		{
		}
	};
CLuaProcessor::CLuaProcessor()
		: m_impl(new Impl)
	{
		...
		GetLuaHelper().PushFunction("GenerateUuid",GenerateUuid);
		bool CLuaHelper::PushFunction(const char* globalName, lua_CFunction function)
		{
			if (IsStackFull())
			{
				return false;
			}

			int n = lua_gettop(m_pMainThread);
			lua_pushcfunction(m_pMainThread, function);
			lua_setglobal(m_pMainThread, globalName);
			ClearStackTempData(n);
			return true;
		}
		m_impl->luaBinder.BindLua(&GetLuaHelper());//把luahelper和binder绑定
		/*
			template <typename T>
			void CLuaBinder<T>::BindLua(CLuaHelper* pLua)
			{
				if (pLua != NULL)
				{
					m_pLS = pLua->m_pMainThread;
					CreateLuaTable();
				}
			}

			template <typename T>
			void CLuaBinder<T>::CreateLuaTable()
			{
				lua_newtable(m_pLS);//创建一个table在放在栈顶
				lua_pushstring(m_pLS, "this");//压入key
				lua_pushlightuserdata(m_pLS, this);//压入value
				lua_settable(m_pLS, -3);//弹出key,value，并设置到table里面去
				lua_pushstring(m_pLS, "LuaCallBack");// 压入key
				lua_pushcfunction(m_pLS, LuaCallback<T>);// 压入value
				lua_settable(m_pLS, -3);//弹出key,value，并设置到table里面去
				lua_setglobal(m_pLS, m_strObjectName.c_str());//设置table的名字,并添加到lua全局变量中,表的名字为scglNet
			}

		*/
		m_impl->luaBinder.BindObject(this);luabinder中T类型为CLuaProcessor,
		m_impl->luaBinder.Register(&CLuaProcessor::Connect, "Connect");//在c++中注册函数,以便在lua中调用
		/*
		template <typename T>
		void CLuaBinder<T>::Register(Function function, const char* functionName)
		{
			int n = lua_gettop(m_pLS);//返回栈顶索引（即栈长度）

			lua_getglobal(m_pLS, m_strObjectName.c_str());//获取lua中名为m_strObjectName.c_str()的table,并压入栈中.
			if (lua_istable(m_pLS, -1)) //判断栈顶元素是否是一个table
			{
				lua_pushstring(m_pLS, functionName);//压入table的key
				lua_pushnumber(m_pLS, m_functions.size());//压入table的value
				lua_settable(m_pLS, -3);//将key，value设置为table中的元素，并将加入的key,value出栈
			}

			lua_pop(m_pLS, lua_gettop(m_pLS) - n);//弹出向lua中压栈的元素

			m_functions.push_back(function);//把注册的函数指针压入保存函数指针的vector对象
		}
		*/
		/* 在lua中调用c++中注册的函数过程.
		在lua中，scglNet.LuaCallBack(scglNet.this, scglNet["Broadcast"], connectionType, BPheader._rawData:data(), packetEx._rawData:data())
		调用c++注册的broadcast函数
		template <typename T>
		int LuaCallback(lua_State* L)
		{
			...
			CLuaBinder<T>* t = NULL;
			if (lua_islightuserdata(L, 1)) //判断是否是ligthuserdata类型
			{
				t = static_cast<CLuaBinder<T>*>(lua_touserdata(L, 1));//返回轻量级的userdata指针
				轻量级userdata是一种表示C指针的值（即void *）
			}
			int funcPos = -1;
			if (lua_type(L, 2) == LUA_TNUMBER)
			{
				funcPos = static_cast<int>(luaL_checknumber(L, 2));
				//luaL_checknumber函数可以检查给定的参数是否为数字：当有错误发生的时候，将抛出一个错误信息；
				//否则返回作为参数的那个数字
			}

			int returnValueAmount = 0;
			if (t && t->m_pObject && funcPos >= 0)
			{
				lua_remove(L, 1);//lua_remove删除给定索引的元素，并将这一索引之上的元素来填补空缺
				lua_remove(L, 1);//这里移除lightuserdata,scglNet["Broadcast"]对应的索引
				returnValueAmount = (t->m_pObject->*(t->m_functions[funcPos]))(L);
				/*
					int CLuaProcessor::Broadcast(lua_State* L)
					{
						.....
					}

				*/
			}
			...
		}
		*/
		...
	}


template <typename T>
class CLuaBinder
{
	private:
		tstring                 m_strObjectName;
		T*                      m_pObject;
		lua_State*              m_pLS;
		std::vector<Function>   m_functions;
};

template <typename T>
	CLuaBinder<T>::CLuaBinder(const char* objectName, T* pObject = NULL, CLuaHelper* pLua = NULL)
		: m_strObjectName(objectName)
		, m_pObject(pObject)
	{
		if (pLua != NULL)
		{
			BindLua(pLua);
		}
	}

2.读取配置
//加载启动配置文件
	scgl::ConfigProcessParam(configFile);

void ConfigProcessParam( const char* configFile, CLuaHelper::LoadFuntion loader /*= NULL*/ )
{
	...
	SLuaHelper::Instance().RunString("require('packet')");
	/*
	bool CLuaHelper::RunString( const char* string )
	{
		if (luaL_dostring(m_pMainThread, string))
		//载入并运行给定的字符串。它被定义为下面的宏：
     	(luaL_loadstring(L, str) || lua_pcall(L, 0, LUA_MULTRET, 0))
		如果没有错误则返回0，发生错误时返回1。
		{
			std::cerr << luaL_checkstring(m_pMainThread, -1) <<  "\n";检查栈中函数参数narg对应的栈顶是否字符串并返回它。
			return false;
		}
		return true;
	}
	*/
	//加载启动配置文件
	{
		VariantVector parameters,results;
		typedef std::vector<CVariant> VariantVector;
		SLuaHelper::Instance().CallFunction("GetConfigParam", &parameters, &results);
		/*
			bool CLuaHelper::CallFunction(const char* functionName, const VariantVector* params, VariantVector* results)
			{
				//调用lua中的全局函数，并将返回值保存
				CLuaFunctor* functor = new CLuaFunctor(m_pMainThread, -1);
				/*
					CLuaFunctor::CLuaFunctor(lua_State* L, int index)
					{
						if (!lua_isfunction(L, index))
						{
							throw std::bad_alloc("not function");
						}
						m_impl->L = L;
						lua_pushvalue(L, index);//将idx索引上的值的副本压入栈顶
						m_impl->functionReference = luaL_ref(L, LUA_REGISTRYINDEX);//存放函数到lua注册表中.并返回当前函数的引用
						LUA_REGISTRYINDEX//lua的注册表
					}
				*/
				function = m_impl->luaFunctors.insert(std::make_pair(std::string(functionName), functor)).first;
				ClearStackTempData(n);
				return (*function->second)(params, results);
				/*
					CLuaFunctor中重载了()
		--------------------------------------------------------			
	bool CLuaFunctor::operator()(const VariantVector* parameters, VariantVector* results)
	{
		if (!lua_checkstack(m_impl->L, static_cast<int>(parameters->size()) + 1))
		{
			return false;
		}

		int n = lua_gettop(m_impl->L); 

		lua_rawgeti(m_impl->L, LUA_REGISTRYINDEX, m_impl->functionReference);lua_rawgeti(lua_State* L,int index,int n)
		//把 t[n] 的值压栈，这里的 t 是指给定索引 index 处的一个值。这是一个直接访问；就是说，它不会触发元方法。
		if (!lua_isfunction(m_impl->L, -1))
		{
			lua_pop(m_impl->L, lua_gettop(m_impl->L) - n);
			return false;
		}

		// 压入参数
		if (parameters && !(parameters->empty()))
		{
			for (VariantVector::const_iterator it = parameters->begin(); it != parameters->end(); ++it)
			{
				PushVariant(m_impl->L, *it);//对参数压栈
			}
		}

		LOG_TRACE("Lua", __FUNCTION__ << boost::this_thread::get_id() << ",this:" << this << ",L:" << m_impl->L);
		// 调用函数 lua_pcall(lua_State *L, int nargs, int nresults, int errfunc)
		nargs:参数个数，nresults：返回值个数，errFunc：错误处理函数，0表示无，表示错误处理函数在栈中的索引
		if (lua_pcall(m_impl->L, lua_gettop(m_impl->L) - 1 - n, LUA_MULTRET, 0))
		{
			LOG_ERROR("Lua", "脚本执行错误，请检查脚本代码:" << luaL_checkstring(m_impl->L, -1));
			lua_pop(m_impl->L, lua_gettop(m_impl->L) - n);
			return false;
		}


		if (results != NULL)
		{
			int retCount = lua_gettop(m_impl->L) - n;
			if (retCount <= 0)
			{
				lua_pop(m_impl->L, lua_gettop(m_impl->L) - n);
				return true;
			}
			// 取得结果
			for (int i = -retCount; i <= -1; ++i)
			{
				CVariant variant = ConvertValue2Variant(m_impl->L, i);
				if (variant != CVariant::NIL)
				{
					results->push_back(variant);//调用lua中函数的返回值保存
				}
				else
				{
					break;
				}
			}
		}
		lua_pop(m_impl->L, lua_gettop(m_impl->L) - n);
		return true;
	}
-------------------------------------------------------------------
				*/
			}
		*/
		if (!results.empty() && results[0].GetMetaType() == CVariant::TYPE_TABLE)
		{
				global_config = results[0].GetTable();
		}
	}

		//加载包定义
	{
		VariantVector parameters;
		VariantVector results;
		SLuaHelper::Instance().CallFunction("GetPacketDetail", &parameters, &results);
		if (!results.empty() && results[0].GetMetaType() == CVariant::TYPE_TABLE)
		{
			const CTable::VariantMap& packets = results[0].GetTable().GetAllValue();
			for (CTable::VariantMap::const_iterator it = packets.begin(); it != packets.end(); ++it)
			{
					const CVariant& value = it->second;
					PushPacketDetail(value, packetDetailMap);
			}
		}
	}
}
3.创建服务
const char* netConfig = scgl::GetGlobalParam("netConfig").GetString();
//从json中取得网络配置表的文件名
scgl::CNetService* netService = new scgl::CNetService(serviceType, netConfig, 300);
scgl::INet& net = *netService;
luaProcessor.SetNet(net);

class CNetService : public INet, public IConnectionManager
{
	CNetService::CNetService(const char* serviceName, const char* configFile /*= NULL*/, unsigned int updateInteval /*= 100*/)
		: m_impl(NULL)
	{
		m_impl = new Impl(serviceName, *this, *this);
		m_impl->updateInteval = updateInteval;

		//服务器端初始化
		boost::property_tree::ptree ptree;
		boost::filesystem::ifstream f(configFile);
		boost::property_tree::read_xml(f, ptree);
		ptree = ptree.get_child("Settings");
		
};