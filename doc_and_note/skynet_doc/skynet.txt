---------------skynet 设计综述--------------
1.skynet核心解决什么问题
作为核心功能,skynet仅仅解决一个问题：
把一个符合规范的C模块,从动态库(so文件)中启动起来，绑定一个永不重复(即使模块退出)的数字id作为其handle
模块被称作服务(service),服务间可以自由发送消息.每个模块可以向skynet框架注册一个callback函数,用来接收
发给它的消息.每个服务都是被一个个消息包驱动.当没有包到来的时候.它们就会处于挂起状态,对CPU资源零消耗.
如果需要自主逻辑,则可以利用skynet系统提供的timeout消息.定期触发.
skynet还提供名字服务,还可以给特定的服务器一个易读的名字，而不是用ID来指代它.id和运行时状态相关,无法保证
每次启动服务，都有一致的id,但名字可以.
2.skynet核心不解决什么问题
skynet的消息传递都是单向的，以数据包为单位传递的。并没有定义出类似TCP连接的概念。也没有约定RPC调用的协议.
不规定数据包的编码格式,没有提供一致的复杂数据结构的列集API.
skynet原则上主张所有的服务都在同一个进程中协作完成。所以在核心层内，不考虑跨机通信的机制，也不为单独一个
服务的崩溃，重启等提供相应的支持。和普通的单线程程序一样，你要为你代码中的bug和意外负责。如果你的程序出了
问题而崩溃，你不应该把错误藏起来，假装它们没有发生。至少，这些不是核心层做的事情。比如使用LUA的沙盒就可以
隔绝大多数逻辑上的BUG
-----------------
简单的说skynet只负责把一个数据包从一个服务内发送出去，让同一进程内的另一个服务收到，调用对应的callback函数
处理。它保证，模块的初始化过程，每个独立的callback调用，都是相互线程安全的。编写服务的人不需要特别的为多线程
环境考虑任何问题。专心处理发送给它的一个个数据包.

熟悉Erlang的同学一眼就能明了，这就是Erlang的Actor模型。只不过，我嵌入了更为熟悉的Lua语言.
为了提供高效的服务间通讯,skynet采用了节点设计,