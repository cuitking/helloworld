task 1  boost::program_options learn 
version boost-1.59
The program_options library allows program developers to obtain program options, that is (name, value) pairs from the user, via conventional methods such as command line and config file
doxygen 和 Graphviz 生成类图工具
http://blog.sina.com.cn/s/blog_a459dcf50102v7ft.html
Doxygen是一种开源跨平台的，以类似JavaDoc风格描述的文档系统，完全支持C、C++、Java、Objective-C和IDL语言，部分支持PHP、C#。注释的语法与Qt-Doc、KDoc和JavaDoc兼容。Doxygen可以从一套归档源文件开始，生成HTML格式的在线类浏览器，或离线的LATEX、RTF参考手册。


使用boost::program_options时,输入命令行参数不存在时，po::parse_command_line(argc, argv, desc)会抛出异常
导致程序dump
可以使用try{} catch(...){} 处理
但是一般的服务器编程中是不用try{} catch(...){}处理的，使用try，不会产生dump文件，不会记录dump时函数的堆栈调用

------done--------

2016 03 04 

http://www.lua.org/manual/5.1/manual.html#2.5.8


2016 03 07 done metable
setmetatable
rawset rawget

2016 0307  lua coroutines

Lua 协同程序(coroutine)与线程比较类似：拥有独立的堆栈，独立的局部变量，独立的指令指针，同时又与其它协同程序共享全局变量和其它大部分东西。
协同是非常强大的功能，但是用起来也很复杂。
线程和协同程序区别
线程与协同程序的主要区别在于，一个具有多个线程的程序可以同时运行几个线程，而协同程序却需要彼此协作的运行。
在任一指定时刻只有一个协同程序在运行，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。
协同程序有点类似同步的多线程，在等待同一个线程锁的几个线程有点类似协同

coroutine.create()	创建coroutine，返回coroutine， 参数是一个函数，当和resume配合使用的时候就唤醒函数调用
coroutine.resume()	重启coroutine，和create配合使用
coroutine.yield()	挂起coroutine，将coroutine设置为挂起状态，这个和resume配合使用能有很多有用的效果
coroutine.status()	查看coroutine的状态
注：coroutine的状态有三种：dead，suspend，running，具体什么时候有这样的状态请参考下面的程序
coroutine.wrap（）	创建coroutine，返回一个函数，一旦你调用这个函数，就进入coroutine，和create功能重复
coroutine.running()	返回正在跑的coroutine，一个coroutine就是一个线程，当使用running的时候，就是返回一个corouting的线程号

---------2016-03-10-------
http://www.runoob.com/lua/lua-coroutine.html
next: producter - customer model

