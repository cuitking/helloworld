Go是一门并发支持，垃圾回收的编译型系统编程语言。
特点：
1。类型安全和内存安全
2.以非常直观和极低代价的方案实现高并发。
3.高效的垃圾回收机制
4.快速编译(同时解决c语言头文件太多的问题)
5.为多核计算机提供性能提升方案，支持utf-8编码

根据约定，GOPATH下需要存放三个文件夹:
bin(存放编译后生成的可执行文件)
    mathapp
pkg(存放编译后生成的包文件)
    平台名/ 如:darwin_amd64, linux_amd64
        mymath.a
        github.com/
            astaxie
                beedb.a
src(存放项目源码)
    mathapp
        main.go
    mymatch/
        sqrt.go

go语言的命令
go get: 获取远程包
go run: 直接运行程序
go build: 测试编译,检查是否有编译错误
go fmt:格式化源码(IDE在自动保存时自动调用)
go install:编译包文件并编译整个程序
go test: 运行测试文件
go doc: 查看手册

go helloworld

sublime text3 打开命令行:ctrl + b

二 go基础知识
go的内置关键字: 
break, default, func, interface, select
case, defer, go, map, struct, chan, else,goto, package, switch,
const, fallthrough, if, range, type, continue, for, import, return, var

注释方法:
// :单行注释
/*...*/ : 多行注释

Go程序的一般结构: basic_structure.go
Go程序是通过package来组织的(和python类似)
只有package 名称为main的包可以包含main函数
一个可执行程序有且仅有一个main包

通过import关键字来导入其它非main包
通过const关键字来进行常量的定义
通过在函数体外部使用var关键字来进行全局变量的声明与赋值
通过type关键字来进行结构(struct)或接口(interface)的声明
通过func关键字来进行函数的声明


Go导入package的格式
import {
    "fmt"
    "io"
    "os"
}
如果导入包之后未调用其中的函数或者类型将会报出编译错误

package 别名
当使用第三方包时，包名可能会非常接近或者相同，此时可以使用别名来进行区别和调用
import {
    io "fmt"
}
io.Println("helloworld")
省略调用
import {
    . "fmt"
}
func main() {
    Println("Hello World!!!!!")
}
不建议使用,易混淆
不可以和别名同时使用

可见性规则
Go语言中,使用大小写来决定该常量,变量，类型，接口，结构或函数是否可以被外部包所调用
根据约定， 函数名首字母小写即为private
函数名首字母大写 即为public

常量定义,常量组
const (
	PI = 3.14
	const1 = "1"
	)
全局变量,var 组只能声明全局变量，不可以在函数体内使用
var (
	name = "gopher"
	name1 = "gopher1"
)
一般类型声明
type newType int
结构声明
type gopher struct{}
接口的声明
type golang interface{}

三 类型与变量

Go基本类型
bool: 长度1字节,取值范围:true, false
注意事项:不可以使用数字代表true或false
整型：int/uint
根据运行平台可能是32位或64位
字节型:byte(uint8别名)
32位整型:int32(rune)/uint32
浮点型:float32(精确到7位小数点)/float64(15位小数点)
足够保存指针的32位或64位整数型:uintptr
其他值类型: array, struct, string
引用类型:slice, map, chan(用于并发)
接口类型:interface
函数类型:func

类型零值
零值并不等于空值,而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为0,
bool为false, string为空字符串.
类型别名
type (
	文本 string
)
func main() {
	var b 文本
	b = "文本类型"
}

单个变量的声明与赋值
变量的声明格式: var 变量名称 变量类型
变量的赋值: 变量名称 = 表达式
声明同时赋值: var 变量名 变量类型 = 表达式
var a int
a = 123
var b int= 321
var c = 321
d := 456(全局变量不可以使用)

多个变量的声明与赋值
全局变量的声明可以使用var()的方式进行简写
全局变量的声明不可以省略var,但可以使用并行方式
所有变量口可以使用类型推断
局部变量不可以使用var()的方式简写,只能使用并行方式
var a,b,c,d = 1,2,3,4

变量的类型转换
go中不存在隐式转换,所有类型转换必须显示声明
转换只能发生在两种相互兼容的类型之间
类型转换的格式:
<ValueA> [:] = <TypeOfValueA>(<ValueB>)
var a float32 = 1.1
b := int(a)

补充说明: 从严格意义上讲type newint int 这里newint并不能说是int的别名，而只是底层数据结构相同，
在这里称为自定义类型，在进行类型转换时仍旧需要显示转换，但 byte和 rune为uint8和int32 的别名,可以相互转换

四 常量与运算符
常量的定义
常量的值在编译时就已经确定
常量的定义格式与变量基本相同
等号右侧必须是常量或者常量表达式
常量表达式中的函数必须是内置函数


常量的初始化规则与枚举
在定义常量组时，如果不提供初始值，则表示将使用上行的表达式
const {
	a = 1
	b
	c
} //b c都为1
使用相同弄的表达式不代表具有相同的值
iota是常量的计数器，从0开始，组中每定义1个常量自动递增1
通过初始化规则与iota可以达到枚举的效果
每遇到一个const关键字,iota就会重置为0

五 控制语句
实现计算机存储单位枚举
const {
	B float64 = 1 << (iota * 10)
	KB
	MB
	GB
}

指针
Go虽然保留了指针，但是与其它编程语言不同的是，在Go当中不支持指针运算以及"->"运算符，而直接采用
"."选择符来操作指针目标对象成员
操作符 "&" 取变量地址，使用 "*" 通过指针间接访问目标对象
默认值为nil 而非null

递增递减语句
在Go当中，++，-- 是作为语句而不是作为表达式，不能将--,++放在变量的左边

判断语句if
条件表达式没有括号
支持一个初始化表达式（可以是并行方式）
左大括号必须和条件语句或else在同一行
支持单行模式
初始化语句中的变量为block级别，同时隐藏外部同名变量
func main() {
    a := true
    if a, b, c := 1,2,3; a+b+c > 6 {

    } else {

    } 
    fmt.Println("xxxxxxxxx")
}

循环语句for
Go只有for一个循环语句关键字，但支持3种形式
初始化和步进表达式可以是多个值
条件语句每次循环都会被重新检查，因此不建议在条件语句中使用函数，尽量提前计算好条件并以变量或常量
代替
左大括号必须和条件语句在同一行
for {}
for d <= 3 {}
for i := 0; i < 3; i++ {}

选择语句switch
可以使用任何类型或表达式作为条件语句
不需要写break，一旦条件符合自动终止
如希望继续执行下一个case，需要使用fallthrough语句
支持一个初始化表达式（可以是并行）,右侧需跟分号
左大括号必须和条件语句在同一行

跳转语句goto,break,continue
三个语法都可以配合标签使用
标签名区分大小写,若不使用会造成编译错误
Break 与continue配合标签可用于多层循环的跳出
Goto 是调整执行位置，与其他两个语句配合标签的结果并不相同

LABLE1:
	for {
		for i := 0; i < 10; i++ {
			if i > 3 {
				break LABLE1
			}
		}
	}
	fmt.Println("0K")
}

六 数组array
定义 var <varName> [n]<type>, n >= 0
数组长度也是类型的一部分，因此具有不同长度的数组为不同类型
注意区分指向数组的指针和指针数组
数组在Go语言中为值类型
数组之间可以使用== 或!=进行比较,但不可使用<或>
可以使用new来创建数组,此方法返回一个指向数组的指针
Go支持多维数组

a := [20]int{19: 2}
fmt.Println(a)

b := [...]int{1, 2, 3, 4, 5, 6}
fmt.Println(b)

c := [...]int{20: 3}
fmt.Println(c)

p := new([10]int)
p[2] = 2
fmt.Println("p ====", p)
q := [10]int{}
q[2] = 2
fmt.Println("q====", q) //都能赋值第三个元素为2

七 切片slice
其本身并不是数组，它指向底层的数组
作为变长数组的替代方案，可以关联底层数组的局部或全部
为引用类型
可以直接创建或从底层数组获取生成
使用len()获取元素个数,cap()获取容量
一般使用make()创建
如果多个slice指向相同底层数组,其中一个的值改变会影响全部
make([]T, len, cap)
其中cap可以省略,则和len的值相同
len表示存数的元素个数,cap表示容量
var s1 []int
a := [10]int{}
s2 := a[5:10] // a [5 6 7 8 9]
s2 := a[:5] //取前五个元素 s2 := a[5:] //取5到最后一个元素
使用make()
s1 := make([]int, 3, 10)
cap容量每次扩容为原来的两倍

Reslice
Reslice时索引以被slice的切片为准
索引不可以超过被slice的切片的容量cap()值
索引越界不会导致底层数组的重新分配而是引发错误

Append
可以在slice尾部追加元素
可以将一个slice追加在另一个slice尾部
如果最终长度未超过追加到slice的容量则返回原始slice
如果超过追加到的slice的容量则将重新分配数组并拷贝原始数据

s1 ：= make([]int, 3, 6)
s1 := append(s1,1,2,3)
s1 := append(s1,4,5,6)

copy
s1 := []int{1,2,3,4,5,6}
s2 := []int{7,8,9}
copy(s1, s2)
fmt.Println(s1) // 7 8 9 4 5 6

第八: map
map:
类似其它语言中的哈希表或者字典,以key-value形式储存数据
key必须是支持== 或!=比较运算的类型,不可以是函数，map或slice
Map查找比线性搜索快很多,但比使用索引访问数据的类型慢100倍
Map使用make()创建, 支持:=这种简写方式

make([keyType]valueType, cap) ,cap表示容量,可省略
超出容量时会自动扩容，但尽量提供一个合理的初始值
使用len()获取元素个数

键值对不存在时自动添加，使用delete()删除某键值对
使用for range 对map和slice进行迭代操作
for k,v := range slice{}
v是slice中对象的一个拷贝，需要修改值，必须使用slice[k] 去访问修改

map简介排序
///map 排序
	newm := map[int]string{1: "a", 2: "b", 3: "c", 4: "d", 5: "e"}
	ms := make([]int, len(newm))
	i := 0
	for k, _ := range newm {
		ms[i] = k
		i++
	}
	fmt.Println("newm-----", newm)
	fmt.Println("ms-------", ms)
	sort.Ints(ms)
	fmt.Println("sort---ms---", ms)

九.函数function
Go函数不支持嵌套,重载和默认参数

但支持以下特性:
无需声明原型，不定长度变参，多返回值，命名返回值参数，匿名函数，闭包

定义函数使用关键字func，且左大括号不能另起一行
函数也可以作为一种类型使用


































