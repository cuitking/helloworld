Go是一门并发支持，垃圾回收的编译型系统编程语言。
特点：
1。类型安全和内存安全
2.以非常直观和极低代价的方案实现高并发。
3.高效的垃圾回收机制
4.快速编译(同时解决c语言头文件太多的问题)
5.为多核计算机提供性能提升方案，支持utf-8编码

根据约定，GOPATH下需要存放三个文件夹:
bin(存放编译后生成的可执行文件)
    mathapp
pkg(存放编译后生成的包文件)
    平台名/ 如:darwin_amd64, linux_amd64
        mymath.a
        github.com/
            astaxie
                beedb.a
src(存放项目源码)
    mathapp
        main.go
    mymatch/
        sqrt.go

go语言的命令
go get: 获取远程包
go run: 直接运行程序
go build: 测试编译,检查是否有编译错误
go fmt:格式化源码(IDE在自动保存时自动调用)
go install:编译包文件并编译整个程序
go test: 运行测试文件
go doc: 查看手册

go helloworld

sublime text3 打开命令行:ctrl + b

二 go基础知识
go的内置关键字: 
break, default, func, interface, select
case, defer, go, map, struct, chan, else,goto, package, switch,
const, fallthrough, if, range, type, continue, for, import, return, var

注释方法:
// :单行注释
/*...*/ : 多行注释

Go程序的一般结构: basic_structure.go
Go程序是通过package来组织的(和python类似)
只有package 名称为main的包可以包含main函数
一个可执行程序有且仅有一个main包

通过import关键字来导入其它非main包
通过const关键字来进行常量的定义
通过在函数体外部使用var关键字来进行全局变量的声明与赋值
通过type关键字来进行结构(struct)或接口(interface)的声明
通过func关键字来进行函数的声明


Go导入package的格式
import {
    "fmt"
    "io"
    "os"
}
如果导入包之后未调用其中的函数或者类型将会报出编译错误

package 别名
当使用第三方包时，包名可能会非常接近或者相同，此时可以使用别名来进行区别和调用
import {
    io "fmt"
}
io.Println("helloworld")
省略调用
import {
    . "fmt"
}
func main() {
    Println("Hello World!!!!!")
}
不建议使用,易混淆
不可以和别名同时使用

代码包声明的基本规则
1.同目录下的源码文件的代码包声明语句要一致，
2.源码文件声明的代码包的名称可以与其所在的目录的名称不同。在针对代码包进行构建时，
生成的结果文件的主名称与其父目录的名称一致.

源码文件所在的目录相对于src目录的相对路径就是它的代码包导入路径，而实际使用其程序实体时给定的限定符
要与它声明所属的代码包名称对应。
为了不让该代码包的使用者产生困惑，我们总是应该让声明的包名与其父目录的名称一致.

什么样的程序实体才可以被当前包外的代码引用
名称的首字母为大写的程序实体才可以被当前包外的代码引用，否则它就只能被当前包内的其他代码引用。

程序实体的访问权限有三种: 包级私有的，模块级私有的和公开的。

模块级私有
internal代码中声明的公开程序实体仅能被该代码包的直接父包及其子包中的代码引用。当然，引用前需要先导入这个
internal包。对于其他代码包，导入该internal包都是非法的，无法通过编译.
问题:
1.如果你需要导入两个代码包,而这两个代码包的导入路径的最后一级是相同的，例如; dep/lib/flag 和 flag 那么会产生冲突吗？
2.如果会产生冲突，那么怎么解决这种冲突，有几种方式.
不一定会产生冲突，如果两个代码包中声明的代码包名称一致，则会产生冲突，如果名称不一致则不会产生冲突.
给包设置别名 import(a "bbb")
导入的点操作 , import(. "bbb")
如果只是引入而没有实际调用 import(_ "bbb")
采取不同的包名声明.


可见性规则
Go语言中,使用大小写来决定该常量,变量，类型，接口，结构或函数是否可以被外部包所调用
根据约定， 函数名首字母小写即为private
函数名首字母大写 即为public

常量定义,常量组
const (
	PI = 3.14
	const1 = "1"
	)
全局变量,var 组只能声明全局变量，不可以在函数体内使用
var (
	name = "gopher"
	name1 = "gopher1"
)
一般类型声明
1 type mystring = string
  mystring是string类型的别名，是完全相同的
  type mystring string
  mystring 和string 是两个不同的类型，这种方式也可以叫做对类型再定义。string可以被称为mystring的潜在类型。
  潜在类型的含义是某个类型在本质上是哪个类型或者哪个类型的集合，潜在类型相同的不同类型的值之间是可以进行类型转换的。即时两个类型的潜在类型相同，它们的值之间也不能进行
  判等或者比较，它们的变量也不能进行赋值。
2 type newType int
  


结构声明
type gopher struct{}
接口的声明
type golang interface{}

iota是golang语言的常量计数器,只能在常量的表达式中使用。
iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。
使用iota能简化定义，在定义枚举时很有用。
const a = iota // a=0 
const ( 
  b = iota     //b=0 
  c            //c=1 
)

const (
	a = 'A'
	c = iota	// c = 1
	d			// d = 2
)

我们可以使用下划线跳过不想要的值
type AudioOutput int

const ( 
    OutMute AudioOutput = iota // 0 
    OutMono                    // 1 
    OutStereo                  // 2 
    _ 
    _ 
    OutSurround                // 5 
)


三 类型与变量

Go基本类型
bool: 长度1字节,取值范围:true, false
注意事项:不可以使用数字代表true或false
整型：int/uint
根据运行平台可能是32位或64位
字节型:byte(uint8别名)
32位整型:int32(rune)/uint32
浮点型:float32(精确到7位小数点)/float64(15位小数点)
足够保存指针的32位或64位整数型:uintptr
其他值类型: array, struct, string
字符串 string 有两种遍历方式
var str string
var tests string = "abcdefghijk"
//方式一,下标遍历
n := len(tests)
for i:= 1; i < n; i++ {
	ch := tests[i]
	fmt.Println(i, ch)
}

for i, ch := range tests {
	fmt.Println("--2---", i, ch)
}
引用类型:slice, map, chan(用于并发)
接口类型:interface
函数类型:func

类型零值
零值并不等于空值,而是当变量被声明为某种类型后的默认值，通常情况下值类型的默认值为0,
bool为false, string为空字符串.
类型别名
type (
	文本 string
)
func main() {
	var b 文本
	b = "文本类型"
}

单个变量的声明与赋值
变量的声明格式: var 变量名称 变量类型
变量的赋值: 变量名称 = 表达式
声明同时赋值: var 变量名 变量类型 = 表达式
var a int
a = 123
var b int= 321
var c = 321
d := 456(全局变量不可以使用)

多个变量的声明与赋值
全局变量的声明可以使用var()的方式进行简写
全局变量的声明不可以省略var,但可以使用并行方式
所有变量口可以使用类型推断
局部变量不可以使用var()的方式简写,只能使用并行方式
var a,b,c,d = 1,2,3,4

变量的类型转换
go中不存在隐式转换,所有类型转换必须显示声明
转换只能发生在两种相互兼容的类型之间
类型转换的格式:
<ValueA> [:] = <TypeOfValueA>(<ValueB>)
var a float32 = 1.1
b := int(a)

补充说明: 从严格意义上讲type newint int 这里newint并不能说是int的别名，而只是底层数据结构相同，
在这里称为自定义类型，在进行类型转换时仍旧需要显示转换，但 byte和 rune为uint8和int32 的别名,可以相互转换

go语言的类型推断可以带来哪些好处
Go 语言的类型推断可以明显提升程序的灵活性，使得代码重构变得更加容易，同时又不会给代码的维护带来额外的负担
更不会损失程序的运行效率

我们通常把不改变某个程序与外界的任何交互方式和规则，而只改变其内部实现的代码修改方式，叫做对该程序的重构.

go语言中代码块一般就是一个由花括号括起来的区域，里面可以包含表达式和语句。go语言本身以及我们编写的代码共同
形成了一个非常大的代码块，也叫全域代码块。

变量重声明的前提条件
1.由于变量的类型在其初始化时就已经确定了， 所有对它再次声明时赋予的类型必须与其原本的类型相同，否则会产生编译错误
2.变量的重声明可能发生在某一个代码块中，如果与当前的变量重名的是外层代码块中的变量，那么就是另一种含义
3.变量的重声明只有在使用短变量声明时才会发生,否则无法通过编译.
4.被声明并赋值的变量必须是多个，并且其中至少一个是新变量。
var err error
n, err := io.WriteString(os.Stdout, "hello world!!")


变量查找顺序
1.首先代码引用变量的时候总会最优先查找当前代码块中的那个变量，注意，这里的当前代码块，仅仅是引用变量的代码
所在的那个代码块，并不包含任何子代码块
2.其次，如果当前代码块中没有声明以此为名的变量，那么程序会沿着代码块的嵌套关系，从直接包含当前代码块的那个
代码块开始，一层一层地查找。
3.一般情况下,程序会一直查到当前代码包代表的那层代码块，如果仍然找不到，编译器就会报错。

使用类型断言表达式 X.(T),其中X代表要被判断的那个值。这个值当下的类型必须是接口类型,

value, ok := interface{}(container).([]string)
当ok 为false，value值为nil
它包括了用来把container变量的值转换为空接口值的interface{}(container)以及一个用于判断前者类型是否为切片类型[]string 的.([]string)
interface{} 代表空接口.
一对不包裹任何东西的花括号，除了可以代表空的代码块之外，还可以用于表示不含任何内容的数据结构.
类型字面值就是用来表示数据类型本身的若干个字符.
类型转换表达式 T(x)
x 可以被叫做源值，它的类型就是源类型，而那个T代表的类型就是目标类型.
类型转换陷阱:
首先，对于整数类型值,整数常量之间的类型转换，原则上只要源值在目标类型的可表示范围内就是合法的
	比如，uint8（255）可以把无类型的常量255转换为uint8类型的值，是因为255在[0,255]的范围内.
	整数在go语言以及计算机中都是以补码形式存储的。补码其实就是源码各位求反再加1.
	当整数值的类型的有效范围由宽变窄时，只需在补码形式下截掉一定数量的高位二进制数即可.
	类似的,当把一个浮点数类型的值转换为整数类型值时，前者的小数部分会被全部截掉。
第二，虽然直接把一个整数值转换为一个string类型的值是可行的，被转换的整数值可以代表一个unicode代码点。
第三，string与各种切片类型之间的互转。
	一个值在从string类型向[]byte 类型转换时代表着以UTF-8编码的字符串会被拆分成零散，独立的字节。
	



四 常量与运算符
常量的定义
常量的值在编译时就已经确定
常量的定义格式与变量基本相同
等号右侧必须是常量或者常量表达式
常量表达式中的函数必须是内置函数


常量的初始化规则与枚举
在定义常量组时，如果不提供初始值，则表示将使用上行的表达式
const {
	a = 1
	b
	c
} //b c都为1
使用相同弄的表达式不代表具有相同的值
iota是常量的计数器，从0开始，组中每定义1个常量自动递增1
通过初始化规则与iota可以达到枚举的效果
每遇到一个const关键字,iota就会重置为0

五 控制语句
实现计算机存储单位枚举
const {
	B float64 = 1 << (iota * 10)
	KB
	MB
	GB
}

指针
Go虽然保留了指针，但是与其它编程语言不同的是，在Go当中不支持指针运算以及"->"运算符，而直接采用
"."选择符来操作指针目标对象成员
操作符 "&" 取变量地址，使用 "*" 通过指针间接访问目标对象
默认值为nil 而非null

递增递减语句
在Go当中，++，-- 是作为语句而不是作为表达式，不能将--,++放在变量的左边

判断语句if
条件表达式没有括号
支持一个初始化表达式（可以是并行方式）
左大括号必须和条件语句或else在同一行
支持单行模式
初始化语句中的变量为block级别，同时隐藏外部同名变量
func main() {
    a := true
    if a, b, c := 1,2,3; a+b+c > 6 {

    } else {

    } 
    fmt.Println("xxxxxxxxx")
}

循环语句for
Go只有for一个循环语句关键字，但支持3种形式
初始化和步进表达式可以是多个值
条件语句每次循环都会被重新检查，因此不建议在条件语句中使用函数，尽量提前计算好条件并以变量或常量
代替
左大括号必须和条件语句在同一行
for {}
for d <= 3 {}
for i := 0; i < 3; i++ {}

选择语句switch
可以使用任何类型或表达式作为条件语句
不需要写break，一旦条件符合自动终止
如希望继续执行下一个case，需要使用fallthrough语句
支持一个初始化表达式（可以是并行）,右侧需跟分号
左大括号必须和条件语句在同一行

跳转语句goto,break,continue
三个语法都可以配合标签使用
标签名区分大小写,若不使用会造成编译错误
Break 与continue配合标签可用于多层循环的跳出
Goto 是调整执行位置，与其他两个语句配合标签的结果并不相同

LABLE1:
	for {
		for i := 0; i < 10; i++ {
			if i > 3 {
				break LABLE1
			}
		}
	}
	fmt.Println("0K")
}

六 数组array
定义 var <varName> [n]<type>, n >= 0
数组长度也是类型的一部分，因此具有不同长度的数组为不同类型
注意区分指向数组的指针和指针数组
数组在Go语言中为值类型
数组之间可以使用== 或!=进行比较,但不可使用<或>
可以使用new来创建数组,此方法返回一个指向数组的指针
Go支持多维数组

a := [20]int{19: 2}
fmt.Println(a)

b := [...]int{1, 2, 3, 4, 5, 6}
fmt.Println(b)

c := [...]int{20: 3}
fmt.Println(c)

p := new([10]int)
p[2] = 2
fmt.Println("p ====", p)
q := [10]int{}
q[2] = 2
fmt.Println("q====", q) //都能赋值第三个元素为2

七 切片slice
其本身并不是数组，它指向底层的数组
作为变长数组的替代方案，可以关联底层数组的局部或全部
为引用类型
可以直接创建或从底层数组获取生成
使用len()获取元素个数,cap()获取容量
一般使用make()创建
如果多个slice指向相同底层数组,其中一个的值改变会影响全部
make([]T, len, cap)
cap()返回当前切片分配的大小,len()返回当前切片存储元素个数
其中cap可以省略,则和len的值相同
len表示存数的元素个数,cap表示容量
var s1 []int
a := [10]int{}
s2 := a[5:10] // a [5 6 7 8 9]
s2 := a[:5] //取前五个元素 s2 := a[5:] //取5到最后一个元素
使用make()
s1 := make([]int, 3, 10)
cap容量每次扩容为原来的两倍

Reslice
Reslice时索引以被slice的切片为准
索引不可以超过被slice的切片的容量cap()值
索引越界不会导致底层数组的重新分配而是引发错误

Append
可以在slice尾部追加元素
可以将一个slice追加在另一个slice尾部
如果最终长度未超过追加到slice的容量则返回原始slice
如果超过追加到的slice的容量则将重新分配数组并拷贝原始数据

s1 ：= make([]int, 3, 6)
s1 := append(s1,1,2,3)
s1 := append(s1,4,5,6)

copy
s1 := []int{1,2,3,4,5,6}
s2 := []int{7,8,9}
copy(s1, s2)
fmt.Println(s1) // 7 8 9 4 5 6

第八: map
map:
类似其它语言中的哈希表或者字典,以key-value形式储存数据
key必须是支持== 或!=比较运算的类型,不可以是函数，map或slice
Map查找比线性搜索快很多,但比使用索引访问数据的类型慢100倍
Map使用make()创建, 支持:=这种简写方式

make([keyType]valueType, cap) ,cap表示容量,可省略
超出容量时会自动扩容，但尽量提供一个合理的初始值
使用len()获取元素个数

键值对不存在时自动添加，使用delete()删除某键值对
使用for range 对map和slice进行迭代操作
for k,v := range slice{}
v是slice中对象的一个拷贝，需要修改值，必须使用slice[k] 去访问修改

map 查找
value, ok := myMap["1234"]
if ok { //找到了
	//处理找到的value
}

map简介排序
///map 排序
	newm := map[int]string{1: "a", 2: "b", 3: "c", 4: "d", 5: "e"}
	ms := make([]int, len(newm))
	i := 0
	for k, _ := range newm {
		ms[i] = k
		i++
	}
	fmt.Println("newm-----", newm)
	fmt.Println("ms-------", ms)
	sort.Ints(ms)
	fmt.Println("sort---ms---", ms)

九.函数function
func Add(a int, b int) (ret int, err error) {}
func add(a,b int) (ret int, err error) {}
func add(a,b int) int {}
Go函数不支持嵌套,重载和默认参数
不定参数类型
func myfunc( args ...int) {}
...type 格式的类型只能作为函数的参数类型存在，并且必须是函数最后一个参数
你希望传任意类型,可以指定类型为interface{}
func Printf(format string, args ...interface{}) {}


但支持以下特性:
无需声明原型，不定长度变参，多返回值，命名返回值参数，匿名函数，闭包

定义函数使用关键字func，且左大括号不能另起一行
函数也可以作为一种类型使用

//匿名函数
	b := func() {
		fmt.Println("---匿名b----")
	}
	b()

Go中的闭包，一个函数和与其相关的引用环境组合而成的实体。
一句关于闭包的名言: 对象是附有行为的数据，而闭包是附有数据的行为


///闭包
func closure(x int) func(int) int {
	return func(y int) int {
		return x + y
	}
}

//调用闭包
	fmt.Println("-----调用闭包-------")
	f := closure(10)
	fmt.Println(f(1))
	fmt.Println(f(2))

package main

import (
    "fmt"
)

func adder() func(int) int {
    sum := 0
    innerfunc := func(x int) int {
        sum += x
        return sum
    }
    return innerfunc
}

func main() {
    pos, neg := adder(), adder()
    for i := 0; i < 10; i++ {
        fmt.Println(pos(i), neg(-2*i))
    }

}

0 0  
1 -2  
3 -6  
6 -12   
10 -20  
15 -30  
21 -42  
28 -56  
36 -72  
45 -90
注意:Go不能在函数内部显式嵌套定义函数，但是可以定义一个匿名函数。如上面所示，我们定义了一个匿名函数对象，然后将其赋值给innerfunc，最后将其作为返回值返回。
当用不同的参数调用adder函数得到（pos(i)，neg(i)）函数时，得到的结果是隔离的，也就是说每次调用adder返回的函数都将生成并保存一个新的局部变量sum。其实这里adder函数返回的就是闭包。

defer
的执行方式类似其他语言中的析构函数，在函数体执行结束后
按照调用的顺序的相反顺序逐个执行
即使函数发生严重错误也会执行
支持匿名函数的调用
常用于资源清理,文件关闭,解锁以及记录时间等操作
通过与匿名函数配合可在return之后修改函数计算结果
如果函数体内某个变量作为defer时匿名函数的参数，则在defer时即已经获得了拷贝，否则则是引用某个变量的地址

Go没有异常机制,但有 panic/recover模式来处理错误
Panic 可以在任何地方引发，但recover只有在defer调用的函数中有效

10 struct

Go中的struct与c中的struct非常相似，并且Go没有class
使用 type<Name> struct{} 定义结构, 名称遵循可见规则
支持指向自身的指针类型成员
支持匿名结构，可用作成员或定义成员变量
匿名结构也可以用于map的值
可以使用字面值对结构进行初始化
允许直接通过指针来读写结构成员
相同类型的成员可进行直接拷贝赋值
支持== 与！= 比较运算符，但不支持 > 或 <
支持匿名字段， 本质上是定义了以某个类型名为名称的字段
嵌入结构作为匿名字段看起来像继承，但不是继承
可以使用匿名字段指针

type person struct {
	Name string
	Age  int
}

a := person{}
	a.Name = "joe"
	a.Age = 30
a := person{
	Name: "joe",
	Age: 22,
}

a := &person{
	Name: "joe",
	Age:  22,
}
a.Name = "fuckaaa" //完全兼容指针类型和值类型 == *a.Name

//匿名结构体
b := &struct {
	Name string
	Age  int
}{
	Name: "jacke",
	Age:  99,
}

//组合
type human struct {
	Sex int
}
type teacher struct {
	human
	Name string
	Age  int
}
d := teacher{Name: "joaaa", Age: 9, human: human{Sex: 2}}
d.Sex = 13

11 方法method
Go中虽没有class，依旧有method
通过显式说明receiver来实现与某个类型的组合
只能为同一个包中的类型定义方法
Receiver可以是类型的值或者指针
不存在方法重载
可以使用值或指针来调用方法，编译器会自动完成转换
从某种意义上来说，方法是函数的语法糖，因为receiver其实就是方法
所接收的第1个参数()
如果外部结构和嵌入结构存在同名方法，则优先调用外部结构的方法
类型别名不会拥有底层类型所附带的方法
方法可以调用结构中的非公开字段

func main() {
	fmt.Println("-----------11. method-----------")
	a := A{}
	a.Print()
}

func (a A) Print() {
	fmt.Println("A")
}

var aa AZ
aa.Print()
(*AZ).Print(&aa) //两种调用方式等同

func (a *AZ) Print() {
	fmt.Println("show -----az print")
}

type AZ int

var ac AZ
	ac = 1
	ac.Increase(100)
	fmt.Println("-----ac------", ac)
func (a *AZ) Increase(num int) {
	*a += AZ(num)
	fmt.Println("-----a--------", a)
}

12 接口interface
接口是一个或多个方法签名的集合
只要某个类型拥有该接口的所有方法签名，即算实现该接口，无需显式
声明实现了哪个接口，这称为structural Typing
接口只有方法声明，没有实现，没有数据字段
接口可以匿名嵌入其它接口，或嵌入到结构中
将对象赋值给接口时，会发生拷贝，而接口内部存储的是指向这个复制品的指针，
既无法修改复制品的状态，也无法获取指针
只有当接口存储的类型和对象都为nil时，接口才等于nil
接口调用不会做receiver的自动转换
接口同样支持匿名字段方法
接口也可实现类似oop中的多太
空接口可以作为任何类型数据的容器


13 反射reflection

反射可大大提高程序的灵活性，使得interface{}有更大的发挥余地
反射使用Typeof和Valueof函数从接口中获取目标对象信息
反射会将匿名字段作为独立字段
想要利用反射修改对象状态，前提是interface.data是settable,即pointer-interface
通过反射可以动态调用方法







14 并发concurrency
goroutine只是由官方实现的超级线程池而已，不过话说回来，每个实例4-5kb的栈内存占用和由于实现机制
而大幅减少的创建和销毁开销，是制造go号称的高并发的根本原因。另外，goroutine的简单易用，也在语言
层面上给予开发者巨大的便利
并发主要由切换时间片来实现同时运行，在并行则是直接利用多核实现多线程的运行，但go可以设置使用核数，
以发挥多核计算机的能力
goroutine 奉行通过通信来共享内存，而不是共享内存来通信

channel
channel 是进程内的通信方式
channel 是goruntine沟通的桥梁，大都是阻塞同步的
通过make创建， close关闭
channel是引用类型
可以使用for range来迭代不断操作channel
可以设置单向或双向通道
可以设置缓存大小，在未被填满前不会发生阻塞
make(chan, 1) 有缓存
有缓存是异步的，无缓存是同步阻塞的
声明:
var chanName chan ElementType
var ch chan int
var m map[string] chan bool 声明一个map，元素是bool型的channel
定义:
ch := make(chan int)
用法:最常见的写入和读出
写入: ch <- value  向channel写入数据通常会导致程序阻塞,直到有其他goroutine从这个channel中读取数据
读取: value := <-ch 如果channel之前没有写入数据,那么从channel中读取数据也会导致程序阻塞,直到channel中被写入数据为止.

select 用于处理异步IO问题
select 的用法和switch语句非常相似,由select开始一个新的选择模块，每个选择条件由case语句来描述,select有比较多的限制，
其中最大的一条限制就是每个case语句里必须是一个IO操作,
select {
	case <- chan1:
	// 如果chan1成功读到数据，则进行该case处理语句
	case chan2 <- 1:
	// 如果成功向chan2写入数据，则进行该case处理语句
	default:
	//
}

使用select实现超时机制，select 的特点是,只要其中一个case已经完成，程序就会执行下去,而不会考虑其他case的情况
timeout := make(chan bool, 1)
go func() {
	time.Sleep(le9)
	timeout <- true
}()

select {
	case <-ch:
		// 从ch中读取到数据
	case <-timeout:
		// 一直没有从ch中读取到数据
}


创建一个带缓冲的channel
c := make(chan int, 1024) 创建一个缓冲为1024的int类型channel，即时没有读取方，写入方也可以一直往channel中写入,在缓冲区被填满之前都不会阻塞

可处理一个或多个channel的发送与接收
同时有多个可用的channel时按随机顺序处理
可用空的select来阻塞main函数
可设置超时

单向channel
var ch2 chan<- float64 // 单向写 float64
var ch3 <-chan int // 单向读 int
类型转换对于channel的意义:在单向channel和双向channel之间进行转换


同步锁
sync提供了两种类型的锁: sync.Mutex sync.RWMutex
Mutex是最简单的，一个goroutine获得了Mutex后，其他goroutine就只能乖乖的等到这个goroutine释放该Mutex.
RWMutex是经典的单写多读模型.在读锁占用的情况下，会阻止写，但不会阻止读.





oop
为类型添加方法
可以给任意类型添加相应的方法
type integer int

func (a integer) Less(b integer) bool {
	return a < b
}

func main() {
	var a integer = 1
	fi a.Less(2) {
		fmt.Println(a, " LESS 2")
	}
}




















