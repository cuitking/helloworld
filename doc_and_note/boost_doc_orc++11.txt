-------------------boost智能指针-------------------

http://blog.csdn.net/jnu_simba/article/details/9569593

boost::shared_ptr 使用boost::make_shared初始化
boost::shared_ptr构造函数会执行两次内存申请，而boost::make_shared则执行一次。
boost::shared_ptr<A> p1 = boost::make_shared<A>();
boost::shared_ptr<A> p2(new A);
boost::shared_ptr<A> p3 = new A();
A* a = std::move(new A());
boost::shared_prt内部会有一个计数器（控制块，用来管理数据）和一个指针，指向数据。因此在执行 Boost::shared_ptr<A> p2(new A) 
的时候，首先会申请数据的内存，然后申请内控制块，因此是两次内存申请，而 boost::make_shared<A>() 
则是只执行一次内存申请，将数据和控制块的申请放到一起
C++11下面,由于有move语义,O2会导致make_shared比new快将近1倍;而O0和C++03的结果无显著差别,说白了,debug版的还是慢很多.

boost::weak_ptr
weak_ptr主要有两个用途：

用来记录对象是否存在了
用来解决shared_ptr环形依赖问题
当要使用weak_ptr来获取shared_ptr的时候，需要得到指向数据的shared_ptr数目，而这正是通过user-count来得到的，而这块内存是分配
在shared_ptr中的，自然有使用的，那就不会释放了，即使数据引用数为0了，但是由于make_shared（）使得数据和控制块一起分配，自然
只要有weak_ptr指向了控制块，就不会释放整块内存了。
shared_ptr<int> p(new int(5));
weak_ptr<int> q(p);

// some time later

if(shared_ptr<int> r = q.lock())
{
    // use *r
}
如果在多线程中，在if之后，但是在使用*r之前，另一个线程对p进行了reset，那次后在使用*r则会抛出异常
在使用weak_ptr的时候，应使用lock方法转换成shared_ptr后使用。
auto global_pack(boost::make_shared<DEFAULT_PACKER>());
boost::shared_ptr<DEFAULT_PACKER> global_pack(boost::make_shared<DEFAULT_PACKER>());


使用时,加入头文件 #include<algorithm>
std::for_each 
template<class InputIterator, class Function>
  Function for_each(InputIterator first, InputIterator last, Function fn)
{
  while (first!=last) {
    fn (*first);
    ++first;
  }
  return fn;      // or, since C++11: return move(fn);
}
返回的是迭代器中的元素.不是迭代器
std::vector<int> veint{1,2,3,4,5,6};
std::for_each(veint.begin(),veint.end(),[](int sum){ std::cout << sum << std::endl;});
std::for_each(veint.begin(),veint.end(),[](int& sum){ sum += 50;});

std::for_each()的返回值
template<class _InIt,
	class _Fn1> inline
	void _For_each(_InIt _First, _InIt _Last, _Fn1& _Func)
	{	// perform function for each element
	for (; _First != _Last; ++_First)
		_Func(*_First);
	}

template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	// perform function for each element
	_DEBUG_RANGE(_First, _Last);
	_DEBUG_POINTER(_Func);
	_For_each(_Unchecked(_First), _Unchecked(_Last), _Func);

	return (_STD move(_Func));
	}
它的返回值就是：std::move(fn). 什么意思，就是返回for_each(begin, end, fn)中的第三个参数fn的move结果，也就是说，如果fn有移动
构造函数，那么返回值就是fn的移动构造结果，否则返回值就是fn的副本（copy构造结果）

----------c++11 lambda表达式------------------
lambda表达式可以方便的构造匿名函数.如果代码中存在大量的小函数,而这些函数一般只被调用一次。不妨将它们重构成lambda表达式
[capture] (params) mutable exception attribute -> ret {body}
[capture] (params) ->ret {body}
[capture] (params) {body}
[capture] {body}

其中

(1) 是完整的 lambda 表达式形式，
(2) const 类型的 lambda 表达式，该类型的表达式不能改捕获("capture")列表中的值。
(3)省略了返回值类型的 lambda 表达式，但是该 lambda 表达式的返回类型可以按照下列规则推演出来：
如果 lambda 代码块中包含了 return 语句，则该 lambda 表达式的返回类型由 return 语句的返回类型确定。
如果没有 return 语句，则类似 void f(...) 函数。
省略了参数列表，类似于无参函数 f()。
mutable 修饰符说明 lambda 表达式体内的代码可以修改被捕获的变量，并且可以访问被捕获对象的 non-const 方法。

exception 说明 lambda 表达式是否抛出异常(noexcept)，以及抛出何种异常，类似于void f() throw(X, Y)。

attribute 用来声明属性。

另外，capture 指定了在可见域范围内 lambda 表达式的代码内可见得外部变量的列表，具体解释如下：

[a,&b] a变量以值的方式呗捕获，b以引用的方式被捕获。
[this] 以值的方式捕获 this 指针。
[&] 以引用的方式捕获所有的外部自动变量。
[=] 以值的方式捕获所有的外部自动变量。
[] 不捕获外部的任何变量。
此外，params 指定 lambda 表达式的参数

lambda函数的类型是std::function
std::function<int(void)> test_func=[](){ return 2;}


boost::container::list::splice( iterator position, list<T,Allocator>& x);
boost::container::list::splice( iterator position, list<T,Allocator>& x, iterator i);
boost::container::list::splice( iterator position, list<T,Allocator>& x, iterator first, iterator last);
函数说明：在list间移动元素：
将x的元素移动到目的list的指定位置，高效的将他们插入到目的list并从x中删除。
目的list的大小会增加，增加的大小为插入元素的大小。x的大小相应的会减少同样的大小。
前两个函数不会涉及到元素的创建或销毁。第三个函数会。
指向被删除元素的迭代器会失效。
参数：position 目的list的位置，用来标明 插入位置 x ,源list、
first,last  x里需要被移动的元素的迭代器。区间为[first, last). 包含first指向的元素，不包含last指向的元素。

boost::asio::io_service.post([this]() {ST_THIS msg_handler();}); 开启另一个线程.执行msg_handler();

-------------------boost::bind-------------------------
对自由方法来说，直接boost::bind(函数名, 参数1，参数2，...)

对类方法来说，直接boost::bind(&类名::方法名，类实例指针，参数1，参数2）

bind &function 
bind绑定一个函数及其参数.function 是类和模板的组合,它定义的对象可以指向一个函数(包装一个函数 )
，类似一个函数指针。既可以直接指向一个函数也可以接收bind的返回值。
bind 返回一个函数对象

void print(int i, int j) { cout << i << " \t " << j << endl;}
boost::bind(print,3,_1)(4);//使用占位符给调用函数传参占个位置：传入4

要用bind绑定类类中的成员函数时，第一个参数表示成员函数的所在类的地址，第二个参数表示具体调用此成员函数的对象。
后面的参数跟bind用于一般函数的用法一致。

class Myfun
{
public:
        void print( int i, int j )
        {  
                cout << i<< "\t" << j << "\n";
       }
};
 
Myfun f;
boost::bind(&Myfun::print,f, 3, 4)();
 
要用bind绑定类类中的成员函数时，第一个参数表示成员函数的所在类的地址，第二个参数表示具体调用此成员函数的对象。
后面的参数跟bind用于一般函数的用法一致

boost::function 
一般函数
若函数定义的形式为：type fun_name( type1 i, type2  j){…}
则使用function指向此函数：function<type(type1 i, type2 j)> tf;
tf=fun_name;
调用函数：tf( 1, 2 );

function模板内"<>"所要使用的类型要和函数的一致：type表示所指函数的返回值类型，type1,type2是所指函数参数的类型。
 
void  print( int i, int j )
{
      cout << i << "\t" << j <<"\n";
 }
 
boost::function<void(inti, int j)> tf;
tf =print;
tf(3, 4);
输出3       4
成员函数
要使用function指向一个类的成员函数时，不管是在指向此成员函数还是调用此成员函数都要让function对象知道其地址（声明function对象时就声明了地址部分）。
调用成员函数时还只能调用某一个对象的成员函数。
class Myfun
{
public:
        void print( int i, int j )
       {
                cout << i<< "\t" << j << "\n";
       }
};
 
boost::function<void(Myfun*,int i, int j)> tf;
tf =&Myfun::print;
Myfun f;
tf(&f::print,3, 4);
输出3       4
function应用直接应用于类的成员函数时，声明时要声明对应成员函数类的指针对象，在调用时再将定义的类对象的地址传入。



bind & function联用
（1）普通函数（非成员函数）
对于普通函数，bind绑定函数全部参数或者全部参数缺省用占位符代替的情况都可以和function连用。不能在bind绑定函数时使用占位符来缺省
部分参数，然后再和function连用，在bind内使用占位符时，如果在bind绑定函数后面补齐参数则与function对象的类型不匹配，如果在
使用function对象时补齐参数，则编译器会报函数参数不一致的错误。
 
（2）用于成员函数
class Myfun
{
public:
        void print( int i, int j )
        {
                cout << i<< "\t" << j << "\n";
        }
};
……...
 boost::function<void(int i, int j)> tf;
 Myfun f;
 tf = boost::bind(&Myfun::print, f, 3, 4);
tf(3, 4);

-----------------------boost::unordered_map-----------------------------

unordered_map、unordered_multimap、unordered_set、unordered_multiset是标准模板库（STL）提供的一类无序关联容器
（unordered associative containers）。是通过哈希表实现的数据结构。无序是指元素的名字（或者键值）的存储是无序的；
这与用平衡二叉树实现的元素名字是有序存储的“关联容器”是相对概念。
今天看到 boost::unordered_map， 它与 stl::map的区别就是，stl::map是按照operator<比较判断元素是否相同，以及比较元素的大小，
然后选择合适的位置插入到树中。所以，如果对map进行遍历（中序遍历）的话，输出的结果是有序的。顺序就是按照operator< 定义的大小排序。
而boost::unordered_map是计算元素的Hash值，根据Hash值判断元素是否相同。所以，对unordered_map进行遍历，结果是无序的。
用法的区别就是，stl::map 的key需要定义operator< 。 
而boost::unordered_map需要定义hash_value函数并且重载operator==。对于内置类型，如string，这些都不用操心。
对于自定义的类型做key，就需要自己重载operator< 或者hash_value()了。 
最后，说，当不需要结果排好序时，最好用unordered_map。

http://blog.csdn.net/orzlzro/article/details/7099231

构造函数，移动构造函数，移动赋值操作符，复制构造函数，赋值操作符，析构函数
http://blog.csdn.net/jofranks/article/details/17438955

question：
bbc convertValue(int a)
{
    std::cout << "convertValue function" << std::endl;
    return a;
}
bbc bbco = convertValue(b); //直接调用bbc的构造函数

-------boost::multi_index_container-------
学习
http://blog.csdn.net/gongxinheng/article/details/5421914
修改一个有序容器（比如map）中某元素的key值会怎么样呢？答案很明显，后果很严重...最起码的，
有序容器很可能就变得无序了，这就是为什么boost的multi_index提供了replace和modify（这俩函数是ordered_index
索引器提供的）成员函数来修改元素的内容，因为有序索引器一定要保证索引序列中的内容是有序的才能用高效
的办法索引到需要的内容，replace方法提供所有迭代器与引用的有效性的保证，它返回一个bool值


stu_num被作为容器的唯一值索引（unique），那么你就等于已经保证了该值不会重复，当然你可以修改成一个不和
其它元素产生冲突的值，但是stu_num为1的值已经存在了，所以replace失败了，结果呢，由于replace方法的保证，
所以容器不会发生任何变化，所以，修改唯一值索引时一定要谨慎了。另外modify方法就没那么严格了，为什么要有
两种修改函数的存在呢？答案是：效率，因为replace会发生两次赋值拷贝，如果结构很大并且使用的很频繁，有可能
会成为性能瓶颈，modify的存在就是出于这种情况的考虑，modify方法有接受两个参数和三个参数的重载


-------------boost::property_tree::ptree-----------

http://blog.csdn.net/yacper/article/details/8025919
http://blog.csdn.net/stelalala/article/details/8967812


----------------POD类型---------------------
http://www.cnblogs.com/tracylee/archive/2012/10/18/2730164.html
----------------------------------------------
------------boost_foreach-------------------
http://www.cnblogs.com/egmkang/archive/2011/05/14/2046205.html
std::vector<int> test;
BOOST_FOREACH(int value,test)
{//...............}
std::map<int32_t,int32_t> _map;
typedef const std::map<int32_t, int32_t>::value_type const_pair;
BOOST_FOREACH(const_pair& node,_map)
{
  //这里就可以访问node的元素
  int32_t key = node.first;
  int32_t value = node.second;
}

-------------boost::asio------------------
http://blog.csdn.net/q601510717/article/details/7732643

------------boost::timer -----------------

http://www.cnblogs.com/lzjsky/archive/2011/05/03/2034994.html
http://zh.highscore.de/cpp/boost/asio.html











